// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: queries.sql

package db

import (
	"context"
)

const createText = `-- name: CreateText :one
insert into pdf_text (filepath, searchable_content, original_content, page, date_created)
values (?, ?, ?, ?, datetime('now'))
returning filepath, page, searchable_content, original_content, date_created
`

type CreateTextParams struct {
	Filepath          string
	SearchableContent string
	OriginalContent   string
	Page              int64
}

func (q *Queries) CreateText(ctx context.Context, arg CreateTextParams) (PdfText, error) {
	row := q.db.QueryRowContext(ctx, createText,
		arg.Filepath,
		arg.SearchableContent,
		arg.OriginalContent,
		arg.Page,
	)
	var i PdfText
	err := row.Scan(
		&i.Filepath,
		&i.Page,
		&i.SearchableContent,
		&i.OriginalContent,
		&i.DateCreated,
	)
	return i, err
}

const deleteTextsByFile = `-- name: DeleteTextsByFile :exec
delete from pdf_text
where filepath = ?
`

func (q *Queries) DeleteTextsByFile(ctx context.Context, filepath string) error {
	_, err := q.db.ExecContext(ctx, deleteTextsByFile, filepath)
	return err
}

const getIndexedFiles = `-- name: GetIndexedFiles :many
select distinct filepath from pdf_text
`

func (q *Queries) GetIndexedFiles(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getIndexedFiles)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var filepath string
		if err := rows.Scan(&filepath); err != nil {
			return nil, err
		}
		items = append(items, filepath)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOriginalTextsByFile = `-- name: GetOriginalTextsByFile :many
select page, original_content from pdf_text
where filepath = ? order by page
`

type GetOriginalTextsByFileRow struct {
	Page            int64
	OriginalContent string
}

func (q *Queries) GetOriginalTextsByFile(ctx context.Context, filepath string) ([]GetOriginalTextsByFileRow, error) {
	rows, err := q.db.QueryContext(ctx, getOriginalTextsByFile, filepath)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOriginalTextsByFileRow
	for rows.Next() {
		var i GetOriginalTextsByFileRow
		if err := rows.Scan(&i.Page, &i.OriginalContent); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTextByFileAndPage = `-- name: GetTextByFileAndPage :one
select filepath, page, searchable_content, original_content, date_created from pdf_text
where filepath = ? and page = ?
order by page
`

func (q *Queries) GetTextByFileAndPage(ctx context.Context, filepath string, page int64) (PdfText, error) {
	row := q.db.QueryRowContext(ctx, getTextByFileAndPage, filepath, page)
	var i PdfText
	err := row.Scan(
		&i.Filepath,
		&i.Page,
		&i.SearchableContent,
		&i.OriginalContent,
		&i.DateCreated,
	)
	return i, err
}

const getTextsByFile = `-- name: GetTextsByFile :many
select filepath, page, searchable_content, original_content, date_created from pdf_text
where filepath = ?
`

func (q *Queries) GetTextsByFile(ctx context.Context, filepath string) ([]PdfText, error) {
	rows, err := q.db.QueryContext(ctx, getTextsByFile, filepath)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PdfText
	for rows.Next() {
		var i PdfText
		if err := rows.Scan(
			&i.Filepath,
			&i.Page,
			&i.SearchableContent,
			&i.OriginalContent,
			&i.DateCreated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const isFileIndexed = `-- name: IsFileIndexed :one
select exists (select 1 from pdf_text where filepath = ?)
`

func (q *Queries) IsFileIndexed(ctx context.Context, filepath string) (int64, error) {
	row := q.db.QueryRowContext(ctx, isFileIndexed, filepath)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const searchTextsByFile = `-- name: SearchTextsByFile :many
select filepath, page, searchable_content, original_content, date_created from pdf_text
where filepath = ? and searchable_content like ?
order by page
`

func (q *Queries) SearchTextsByFile(ctx context.Context, filepath string, searchableContent string) ([]PdfText, error) {
	rows, err := q.db.QueryContext(ctx, searchTextsByFile, filepath, searchableContent)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PdfText
	for rows.Next() {
		var i PdfText
		if err := rows.Scan(
			&i.Filepath,
			&i.Page,
			&i.SearchableContent,
			&i.OriginalContent,
			&i.DateCreated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
